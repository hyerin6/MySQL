# 트랜잭션과 잠금        
MySQL의 동시성에 영향을 미치는 잠금(Lock)과 트랜잭션, 트랜잭션 격리수준에 대해 알아보자.    

* 트랜잭션    
작업의 완전성을 보장해주는 것이다.              
논리적인 작업셋을 완벽하게 처리 또는 처리하지 못할 경우 원상태로 복구해서          
작업의 일부만 적용되는 현상(Partial update)이 발생하지 않게 만들어주는 기능이다.          

* 잠금   
동시성을 제어하기 위한 기능       
<br />         
   
## 트랜잭션   

#### MySQL에서 트랜잭션         
트랜잭션은 하나의 쿼리가 있든, 두 개 이상의 쿼리가 있든 관계없이 100% 적용되거나 아무것도 적용되지 않아야 함을 보장해 주는 것이다.
트랜잭션 관점에서 InnoDB 테이블과 MyISAM 테이블의 차이를 살펴보자.          

```
CREATE TABLE tab_myisam ( fdpk INT NOT NULL, 
    PRIMARY KEY ( fdpk ) ) ENGINE=MyISAM;

CREATE TABLE tab_innodb ( fdpk INT NOT NULL, 
    PRIMARY KEY ( fdpk ) ) ENGINE=INNODB;
```

테스트용 테이블에 각각 레코드 1건씩 저장 후 `AUTO-COMMIT` 모드에서 다음 쿼리 문장을 InnoDB 테이블과 MyISAM 테이블에서 각각 실행해보자.   

```
INSERT INTO tab_myisam (fdpk) VALUES (1), (2), (3);
INSERT INTO tab_innodb (fdpk) VALUES (1), (2), (3);
```

두 개의 스토리지 엔진에서 결과는 다음과 같다.   

```
mysql> INSERT INTO tab_myisam (fdpk) VALUES (1), (2), (3);
ERROR 1062 (23000): Duplicate entry '3' for key 'PRIMARY'

mysql> INSERT INTO tab_innodb (fdpk) VALUES (1), (2), (3);
ERROR 1062 (23000): Duplicate entry '3' for key 'PRIMARY'

mysql> SELECT * FORM tab_myisam;
+------+
| fdpk |
+------+
|     1|
|     2|
|     3|
+------+

mysql> SELECT * FORM tab_innodb;
+------+
| fdpk |
+------+
|     1|
+------+
```

두 INSERT 문장 모두 PRIMARY KEY 중복 오류로 쿼리가 실패했다.   
그런데 MyISAM 테이블에 "1"과 "2"는 INSERT된 상태로 남아있다.   

MEMORY 스토리지 엔진이나 MERGE 스토리지 엔진을 사용하는 테이블도 MyISAM 테이블과 동일하게 작동한다.   
MyISAM 테이블에서 발생하는 이러한 현상을 부분 업데이트라고 표현하며, 부분 업데이트 현상은 테이블 데이터의 정합성을 맞추는데 상당히 어려운 문제를 만들어낸다.
<br />    

#### 주의사항    
트랜잭션 또한 DBMS의 커넥션과 동일하게 최소의 코드에만 적용하는 것이 좋다.   
-> 프로그램 코드에서 트랜잭션의 범위를 최소화하라는 의미다.   

다음은 게시물 작성 후 저장하는 기능의 서버 처리 과정이다.     
```  
1. 처리 시작   
=> 데이터베이스 커넥션 생성
=> 트랜잭션 시작    
2. 사용자의 로그인 여부 확인 
3. 사용자의 글 내용 오류 여부 확인 
4. 첨부 파일 확인 및 저장 
5. 사용자의 입력 내용 DBMS에 저장 
6. 첨부 파일 정보를 DBMS에 저장 
7. 저장된 내용 또는 기타 정보 DBMS에서 조회 
8. 게시물 등록에 대한 알림 메일 발송 
9. 알림 메일 발송 이력을 DBMS에 저장 
<= 트랜잭션 종료 (COMMIT)
<= 데이터베이스 커넥션 반납 
10. 처리 완료
```  

위 절차 중 DBMS의 트랜잭션 처리에 좋지 않은 영향을 끼치는 부분을 알아보자.   

많은 개발자가 데이터베이스의 커넥션을 생성하는 코드를 1번과 2번 사이에 구현하며 그와 동시에 "START TRANSACTION" 명령으로 트랜잭션을 시작한다.   
그리고 9번과 10번 사이에서 트랜잭션을 COMMIT하고 커넥션을 종료한다.   
커넥션을 소유하는 시간이 길어지면 어느 순간 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있다.

더 큰 위험은 8번 작업이라고 볼 수 있다.          
프로그램이 실행되는 동안 메일 서버와 통신할 수 없는 상황이 발생한다면 웹 서버뿐 아니라 DBMS 서버까지 위험해지는 상황이 발생할 것이다.           
메일 전송이나 FTP 파일 전송 작업 또는 네트워크를 통해 원격 서버와 통신하는 등의 작업은 DBMS의 트랜잭션 내에서 제거하는 것이 좋다.

이 처리 절차에서 DBMS의 작업이 크게 4가지가 있다.     
* 사용자가 입력한 정보를 저장하는 5, 6번 작업은 반드시 하나의 트랜잭션으로 묶어야함    
* 7번 작업은 저장된 데이터의 단순 확인 및 조회이므로 트랜잭션에 포함될 필요 없음     
* 9번 작업은 조금 성격이 다르기 때문에 이전 트랜잭션(5, 6번)에 함께 묶지 않아도 무방해보임    
이러한 작업은 별도의 트랜잭션으로 분리하는 것이 좋다.   
* 7번 작업은 단순 조회라고 본다면 별도로 트랜잭션을 사용하지 않아도 무방해보임  
<br />        
  
이러한 내용을 적용해서 처리 절차를 다시 설계해보자.   

``` 
1. 처리 시작 
2. 사용자 로그인 여부 확인 
3. 사용자의 글 내용의 오류 발생 여부 확인 
4. 첨부된 파일 확인 및 저장 
=> 데이터베이스 커넥션 생성 
=> 트랜잭션 시작 
5. 사용자의 입력 내용을 DBMS에 저장 
6. 첨부 파일 정보를 DBMS에 저장 
<= 트랜잭션 종료(COMMIT)
7. 저장된 내용 또는 기타 정보를 DBMS에서 조회 
8. 게시물 등록에 대한 알림 메일 발송 
=> 트랜잭션 시작 
9. 알림 메일 발송 이력을 DBMS에 저장 
<= 트랜잭션 종료(COMMIT)
<= 데이터베이스 커넥션 종료
10. 처리 완료 
``` 

위 예제가 최적의 설계가 아닐 수 있으나 설명하고자 하는 것은 프로그램의 코드가 데이터베이스 커넥션을 가지고 있는 범위와         
트랜잭션이 활성화돼 있는 프로그램의 범위를 최소화해야 한다는 것이다.
<br />    

## MySQL 엔진의 잠금    
MySQL에서 사용되는 잠금은 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나눠볼 수 있다.   

* MySQL 엔진 레벨의 잠금: 모든 스토리지 엔진에 영향을 미친다.    
테이블 데이터 동기화를 위한 잠금 이외에도 유저 락과 네임 락이라는 것도 제공한다.      
* 스토리지 엔진 레벨의 잠금: 스토리지 엔진 간 상호 영향을 미치지 않는다.              
<br />               

#### 글로벌 락            
글로벌 락은 MySQL에서 제공하는 잠금 가운데 가장 범위가 크다.   
한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 대부분의 DDL 문장이나 DML 문장을 실행하는 경우     
글로벌 락이 해제될 때까지 해당 문장이 대기 상태로 남는다.   
범위는 MySQL 서버 전체이며, 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향을 미친다.
여러 데이터베이스에 존재하는 MyISMA이나 MEMORY 테이블에 대해 mysqldump로 일관된 백업을 받아야 할 때 글로벌 락을 사용해야 한다.   
<br />            

#### 테이블 락(TABLE LOCK)     
개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있다.   
테이블 락은 MyISAM 뿐만 아니라 InnoDB 스토리지 엔진을 사용하는 테이블도 동일하게 설정할 수 있다.   
명시적인 테이블 락도 특별한 상황이 아니면 애플리케이션에서 거의 사용할 필요가 없다.   
글로벌 락과 동일하게 온라인 작업에 상당한 영향을 미치기 때문이다.   

묵시적인 테이블 락은 MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.   
MySQL 서버가 데이터가 변경되는 테이블에 잠금을 설정하고 데이터를 변경한 후, 즉시 잠금을 해제하는 형태로 사용된다.   
하지만 InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에     
단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지는 않는다.       
더 정확히는 InnoDB 테이블에도 테이블 락이 설정되지만 대부분의 데이터 변경(DML) 쿼리에서는 무시되고 스키마를 변경하는 쿼리(DDL)의 경우에만 영향을 미친다.    
<br />     

#### 유저 락(USER LOCK)   
유저 락은 단순히 사용자가 지정한 문자열(String)에 대해 획득하고 반납(해제)하는 잠금이다.     
예를 들어 데이터베이스 서버 1개에 5대의 웹 서버가 접속해서 서비스를 하고 있는 상황에서 5대의 웹 서버가 어떤 정보를 동기화해야 하는 요건처럼       
여러 클라이언트가 상호 동기화를 처리해야 할 때 데이터베이스의 유저 락을 이용하면 쉽게 해결할 수 있다.        

또한, 많은 레코드를 한 번에 변경하는 트랜잭션의 경우에 유용하게 사용할 수 있다.   
배치 프로그램처럼 한꺼번에 많은 레코드를 변경하는 쿼리는 자주 데드락의 원인이 되곤 한다.   
이러한 경우 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 유저 락을 걸고 쿼리를 실행하면 아주 간단히 해결할 수 있다.    
<br />

#### 네임 락  
데이터베이스 객체(대표적으로 테이블이나 뷰 등)의 이름을 변경하는 경우 획득하는 잠금이다.   
네임 락은 명시적으로 획득하거나 해제할 수 있는 것이 아니고 "RENAME TABLE tab_a TO tab_b" 같이   
테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금이다.     
RENAME TABLE 명령의 경우 원본 이름과 변경될 이름 두 개 모두 한꺼번에 잠금을 설정한다.   

또한 실시간으로 테이블을 바꿔야 하는 요건이 배치 프로그램에서 자주 발생하는데, 다음 예제를 살펴보자.    

```
-- // 배치 프로그램에서 별도의 임시 테이블(rank_new)에 서비스용 랭킹 데이터를 생성 

-- // 랭킹 배치가 완료되면 현재 서비스용 랭킹 테이블(rank)을 rank_backup으로 백업하고 
-- // 새로 만들어진 랭킹 테이블(rank_new)을 서비스용으로 대체하고자 하는 경우 

mysql> RENAME TABLE rank TO rank_backup , rank_new TO rank; 
```

위와 같이 하나의 RENAME TABLE 명령문에 두 개의 RENAME 작업을 한꺼번에 실행하면 실제 애플리케이션에서는   
"Table not found 'rank'"와 같은 상황이 발생시키지 않고 적용하는 것이 가능하다.   
하지만 아래와 같이 2개로 나눠서 실행하면 아주 짧은 시간이지만 'rank' 테이블이 존재하지 않는 순간이 생기게 되며,   
그 순간에 실행되는 쿼리는 "Table not found 'rank'" 오류를 발생시킨다.   

```
mysql> RENAME TABLE rank TO rank_backup;
mysql> RENAME TABLE rank_new To rank;
```
<br />        

## MyISAM과 MEMORY 스토리지 엔진의 잠금         
MyISAM과 MEMORY 스토리지 엔진은 자체적인 잠금을 가지지 않고 MySQL 엔진에서 제공하는 테이블 락을 그대로 사용한다.   
그리고 MyISAM과 MEMORY 스토리지 엔진에서 쿼리 단위로 필요한 잠금을 한꺼번에 요청해서 획득하기 때문에 데드락이 발생할 수 없다.   
<br />     

#### 잠금 획득    
* 읽기 잠금   
테이블에 쓰기 잠금이 걸려 있지 않으면 바로 읽기 잠금을 획득하고 읽기 작업을 시작할 수 있다.   
  
* 쓰기 잠금    
테이블에 아무런 잠금이 걸려 있지 않아야만 쓰기 잠금을 획득할 수 있고, 그렇지 않다면 다른 잠금이 해제될 때까지 대기해야 한다.       
<br />       

#### 잠금 튜닝       
테이블 락에 대한 작업 상황은 MySQL의 상태 변수를 통해 확인할 수 있다.   
```
mysql> SHOW STATUS LIKE 'Table%';
+-----------------------+---------+
| Variable_name         | Value   |
+-----------------------+---------+
| Table_locks_immediate | 1151552 | 
| Table_locks_waited    | 15324   |
+-----------------------+---------+
```

"Table_locks_immediate"는 다른 잠금이 풀리기를 기다리지 않고 바로 잠금을 획득한 누적 횟수    
"Table_locks_waited"는 다른 잠금이 이미 해당 테이블을 사용하고 있어서 기다려야 했던 누적 횟수

```
잠금 대기 쿼리 비율 = Table_locks_waited / (Table_locks_immediate + Table_locks_waited) * 100;
```

위 결과는 1.31%, 즉 쿼리 100개 중 1개는 잠금 대기를 겪고 있다는 것이다.      
만약 이 수치가 높고 테이블 잠금 때문에 경합(Lock contention)이 많이 발생하고 있으면 자연히 처리 성능이 영향을 받고 있음을 의미하므로     
테이블을 분리한다거나 InnoDB 스토리지 엔진으로 변환하는 방법을 고려해 보는 것이 좋다.        

InnoDB 스토리지 엔진의 경우 레코드 단위의 잠금을 사용하기 때문에 집계에 포함되지 않는다.       
집계된 수치는 MyISAM이나 MEMORY 또는 MERGE 스토리지 엔진을 사용하는 테이블이 대상이 된다.           
<br />            

#### 테이블 수준의 잠금 확인 및 해제      
MyISAM이나 MEMORY 등과 같은 스토리지 엔진을 사용하는 테이블은 모두 테이블 단위의 잠금이므로        
테이블을 해제하지 않으면 다른 클라이언트에서 그 테이블을 사용하는 것은 불가능하다.          
하나의 테이블에서 전혀 다른 레코드라 하더라도 동시에 변경하는 것은 불가능하기 때문에 쿼리 처리의 동시성이 떨어지게 된다.    
<br />                 

## InnoDB 스토리지 엔진의 잠금       
InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다.    
InnoDB는 레코드 기반의 잠금 방식 때문에 MyISAM보다는 훨씬 뛰어난 동시성 처리를 제공할 수 있다.      
<br />  

#### InnoDB의 잠금 방식   
* 비관적 잠금   
현재 트랜잭션에서 변경하고자 하는 레코드에 대해 잠금을 획득하고 변경 작업을 처리하는 방식을 비관적 잠금이라고 한다.   
'현재 변경하고자 하는 레코드를 다른 트랜재견에서도 변경할 수 있다.' 라는 비관적인 가정을 하기 때문에 먼저 잠금을 획득한 것이다.         
일반적으로 높은 동시성 처리에는 비관적 잠금이 유리하다고 알려져 있으며 InnoDB는 비관적 잠금 방식을 채택하고 있다.     
 
* 낙관적 잠금     
낙관적 잠금에서 기본적으로 각 트랜잭션이 같은 레코드를 변경할 가능성은 상당히 희박할 것이라고(낙관적으로) 가정한다.          
그래서 우선 변경 작업을 수행하고 마지막에 충돌이 있었는지 확인해 문제가 있으면 ROLLBACK 처리하는 방식을 의미한다.             
<br />            
  