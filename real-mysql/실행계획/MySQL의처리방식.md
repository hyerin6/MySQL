# MySQL의 주요 처리 방식    
"풀 테이블 스캔"을 제외한 나머지는 모두 스토리지 엔진이 아니라 MySQL 엔진에서 처리되는 내용이다.   
MySQL 엔진에서 부가적으로 처리하는 작업은 대부분 성능에 미치는 영향력이 큰데 모두 쿼리의 성능을 저하시키는데 한몫하는 작업이다.    

MySQL 엔진에서 처리하는 데 시간이 오래 걸리는 작업의 원리를 알알둔다면 쿼리를 튜닝하는 데 상당히 많은 도움이 될 것이다.   

<br />         

## 1. 풀 테이블 스캔   
풀 테이블 스캔은 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미한다.    
MySQL 옵티마이저는 다음과 같은 조건이 일치할 때 주로 풀 테이블 스캔을 선택한다.    

* 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽은 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우   
  (일반적으로 테이블이 페이지 1개로 구성된 경우)        
  
* WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우    

* 인덱스 레인지 스캔을 사용할 수 있는 쿼리라 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우    
  (인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)      
  
* 반대로 max_seeks_for_key 변수를 특정 값(N)으로 설정하면 MySQL 옵티마이저는 인덱스의 기수성(Cardinality)이나     
  선택도(Selectivity)를 무시하고, 최대 N건만 읽으면 된다고 판단하게 한다.     
  이 값을 작게 설정할수록 MySQL 서버가 인덱스를 더 사용하도록 유도함.    
<br />      
  
일반적으로 테이블의 전체 크기는 인덱스보다 훨씬 크기 때문에 테이블을 처음부터 끝까지 읽는 작업은 상당히 많은 디스크 읽기가 필요하다.     
대부분의 DBMS는 풀 테이블 스캔을 실행할 때 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능이 있으며 그 수를 조절할 수 있다.    
즉 디스크로부터 페이지를 하나씩 읽어 오는 것은 아니다. 근데 페이지 수를 지정하는건 불가능 > 이것은 MyISAM 에 해당하는 이야기   

InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 얽히면 백그라운드 스레드에 의해 리드 어헤드(Read ahead) 작업이 자동으로 시작된다.    
리드 어헤드란 어떤 영역의 데이터가 앞으로 필요해질 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것을 의미한다.    

* 풀 테이블 스캔이 실행하면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 실행   
* 특정 시점부터는 백그라운드 스레드로 넘겨, 한 번에 최대 64개의 페이지 읽어 버퍼 풀에 저장   

포그라운드 스레드는 버퍼 풀의 데이터를 가져다 사용하기 때문에 쿼리가 상당히 빨리 처리된다.    

<br />  

## 2. ORDER BY 처리 (Using filesort)       
레코드 1~2건을 가져오는 쿼리를 제외하면 대부분 SELECT 쿼리에서 정렬은 필수적으로 사용된다.    
정렬 처리를 위한 방법은 다음과 같다.   

|방법|장점|단점|
|------|---|---|
|인덱스를 이용|INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬돼 있어서 <br /> 순서대로 읽기만 하면 되므로 매우 빠르다.|INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다. <br /> 인덱스 때문에 디스크 공간이 더 많이 필요하다. <br /> 인덱스가 개수가 늘어날수록 InnoDB의 버퍼 풀이나 MyISAM의 키 캐시용 메모리가 많이 필요하다.|
|Filesort 이용|인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때의 단점이 장점으로 바뀐다. <br /> 정렬애햐 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠르다.|정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.|   

<br />   
 
항상 Filesort 정렬 작업을 거쳐야 하는 것은 아니며     
다음과 같은 이유로 모든 정렬을 인덱스를 이용하도록 튜닝하기란 거의 불가능하다.  

* 정렬 기준이 너무 많아 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우    
* GROUP BY의 결과 또는 DISTINCT와 같은 처리의 결과를 정렬해야 하는 경우    
* UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우    
* 랜덤하게 결과 레코드를 가져와야 하는 경우 (때로는 인덱스를 이용할 수 있도록 개선할 수 있어야 한다.   
<br />     
  
MySQL이 인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지는 실행 계획의 Extra 칼럼에 "Using filesort"가 표시되는지로 판단할 수 있다.    


<br />     

### 소트 버퍼 (Sort buffer)     
MySQL은 정렬을 위해 별도의 메모리 공간을 할당 받아서 사용하는데 이 메모리 공간을 소트 버퍼라고 한다.    

* 정렬이 필요한 경우에만 할당되며 쿼리 실행이 완료되면 즉시 시스템으로 반납된다.    
* 정렬해야 할 레코드의 건수가 소트 버퍼로 할당된 공간보다 크다면 어떻게 될까?    
    - MySQL은 정렬해야 할 레코드를 여러 조각으로 나눠서 처리한다.    
    이 과정에서 임시 저장을 위해 디스크를 사용한다.    
    
<br />      

### 정렬 알고리즘   
레코드 전체를 소트 버퍼에 담을지 기준 칼럼만 담을지에 따라 구분할 수 있다.    
<br />

#### 1) 싱글 패스(Single pass) 알고리즘    
소트 버퍼에 정렬 기준 칼럼을 포함해 SELECT되는 칼럼 전부를 담아서 정렬하는 방법이다.    


#### 2) 투 패스(Two pass) 알고리즘   
정렬 대상 칼럼과 프라이머리 키값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서   
SELECT할 칼럼을 가져오는 알고리즘으로 예쩐 버전의 MySQL에서 사용하던 방법이다.    

정렬이 완료되면 결과를 순서대로 테이블에서 한 번 더 읽어서 SELECT 칼럼을 가져온다.  
이 방식은 (같은 레코드) 테이블을 두 번 읽어야 하기 때문에 불합리하다. 하지만 싱글 패스 알고리즘은 더 많은 소트 버퍼 공간이 필요하다.    
  

싱글 패스 알고리즘은 정렬 대상 레코드가 적은 경우 빠른 성능을 보이고,   
투 패스 알고리즘은 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적이라고 볼 수 있다.      


<br />     

### 정렬의 처리 방식    
쿼리에 ORDER BY가 사용되면 반드시 다음 방식 중 하나로 정렬이 처리된다.    
일반적으로 밑쪽에 있는 방법으로 갈수록 처리가 느려진다.   

|정렬 처리 방법|실행 계획의 Extra 코멘트|
|---|---|
|인덱스 사용한 정렬|별도의 내용 표기 없음|
|드라이빙 테이블만 정렬 <br /> (조인이 없는 경우 포함)|"Using filesort"가 표시됨|
|조인 결과를 임시 테이블로 저장한 후, <br /> 임시 테이블에서 정렬|"Using temporary; Using filesort"가 표시됨|

<br />   

먼저 옵티마이저는 정렬 처리를 위해 인덱스를 이용할 수 있는지 검토할 것이다.     
만약 인덱스를 이용할 수 있다면 별도의 "Filesort" 과정 없이 인덱스를 순서대로 읽어서 결과를 반환한다.     
하지만 인덱스를 이용할 수 없다면 WHERE 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 정렬을 처리할 것이다.     

이때 MySQL 옵티마이저는 정렬 대상 레코드를 최소화하기 때문에 다음 두 가지 방법중 하나를 선택한다.   
1. 드라이빙 테이블만 정렬한 다음 조인을 수행    
2. 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행     

일반적으로 조인이 수행되면서 레코드 건수는 거의 배수로 불어나기 때문에 가능하다면 드라이빙 테이블만 정렬한 다음 조인을 수행하는 방법이 효율적이다.    
그래서 두 번째 방법보다는 첫 번째 방법이 더 효율적으로 처리된다.    

<br />      

#### 1) 인덱스를 이용한 정렬     
* 인덱스를 이용한 정렬을 위해 반드시 ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블에 속하고 (조인 사용 시 드라이빙 테이블)    
ORDER BY의 순서대로 생성된 인덱스가 있어야 한다.    
  
* WHERE 절에 첫 번째 읽는 테이블의 칼럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다.   

* B-Tree 계열의 인덱스가 아닌 해시나 전문 검색 인덱스 등에서는 인덱스를 이용한 정렬을 사용할 수 없다.   

* 인덱스를 이용한 정렬의 경우 MySQL 엔진에서 별도의 정렬을 위한 추가 작업을 수행하지 않는다.   
<br />      

```
SELECT * FROM employees e, salaries s
WHERE s.emp_no=e.emp_no
AND e.emp_no BETWEEN 100002 AND 100020 
ORDER BY e.emp_no;

-- // emp_no 칼럼으로 정렬이 필요한데 인덱스를 사용하면서 자동 정렬이 된다고 
-- // 일부러 ORDER BY emp_no를 제거하는 것은 좋지 않은 선택이다. 
SELECT * FROM employees e, salaries s
WHERE s.emp_no=e.emp_no
AND e.emp_no BETWEEN 100002 AND 100020;
```

위 예제는 ORDER BY가 있건 없건 인덱스를 레인지 스캔해서 결과는 같다.    
ORDER BY 절이 없어도 정렬되는 이유는 employees 테이블의 프라이머리 키를 읽고, 그 다음 salaries 테이블을 조인했기 때문이다.    

즉 B-Tree 인덱스가 키 값으로 정렬돼 있고 조인이 네스티드-루프 방식으로 실행되기 때문에 조인 때문에 드라이빙 테이블의 인덱스 읽기 순서가 흐트러지지 않는다.   
조인이 사용된 쿼리의 실행 계획에 조인 버퍼가 사용되면 순서가 흐트러질 수 있기 때문에 주의해야 한다.   

<br />      

#### 2) 드라이빙 테이블만 정렬    
일반적으로 조인이 수행되면 레코드 수가 증가      
-> 조인 실행 전 드라이빙 테이블 레코드만 정렬하고 조인하자.    
-> 드라이빙 테이블의 칼럼만 ORDER BY 절이 작성돼야 한다.     


**예)**  
```
SELECT * FROM employees e, salaries s 
WHERE s.emp_no=e.emp_no 
  AND e.emp_no BETWEEN 100002 AND 100020
ORDER BY e.last_name;
```

우선 WHERE 절이 다음 조건을 만족해야 옵티마이저가 employees 테이블을 드라이빙 테이블로 선택할 것이다. 
1. WHERE 절의 검색 조건은 employees 테이블의 프라이머리 키를 이용해 검색하면 작업량을 줄일 수 있다.    
2. 드리븐 테이블(salaries)의 조인 칼럼인 emp_no 칼럼에 인덱스가 있다.    
<br />         
   
검색은 인덱스 레인지 스캔으로 처리할 수 있지만 ORDER BY 절에 명시된 칼럼은      
employees 테이블의 프라이머리 키와 전혀 연관이 없기 때문에 인덱스를 이용한 정렬을 불가능하다.      
그러나 ORDER BY 절의 정렬 기준 칼럼이 드라이빙 테이블에 포함된 칼럼임을 알 수 있기 때문에   
옵티마이저는 드라이빙 테이블만 검색해서 정렬을 먼저 수행하고 그 결과와 salaries 테이블을 조인한 것이다.   

위 SELECT 쿼리 수행 과정은 다음과 같다.   
1. 인덱스를 이용해 WHERE 조건을 만족하는 레코드 검색   
2. 검색 결과를 last_name 칼럼으로 정렬 수행(Filesort)   
3. 정렬된 결과를 순서대로 읽으면서 salaries 테이블과 조인을 수행해서 최종 결과를 가져옴   

<br />   

#### 3) 임시 테이블을 이용한 정렬   
```
SELECT * FROM employees e, salaries s 
WHERE s.emp_no=e.emp_no AND e.emp_no BETWEEN 100002 AND 100020
ORDER BY s.salary;
```

위 쿼리는 ORDER BY 절의 정렬 기준 칼럼이 드라이빙 테이블이 아니라 드리븐 테이블에 있는 칼럼이다.     
즉 정렬이 수행되기 전에 반드시 salaries 테이블을 읽어야 하므로 이 쿼리는 반드시 조인된 데이터를 가지고 정렬할 수 밖에 없다.       

쿼리의 실행 계획을 보면 Extra 칼럼에 "Using temporary; Using filesort" 라는 메시지가 표시된다.      
이는 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬 처리했음을 의미한다.       

<br />  

#### 정렬 방식의 성능 비교   
쿼리에서 ORDER BY와 함께 LIMIT이 사용되는 경향이 있다.       
일반적으로 LIMIT은 테이블이나 처리 결과의 일부만 가져오기 때문에 MySQL 서버가 처리해야 할 작업량을 줄이는 역할을 한다.   
하지만 ORDER BY나 GROUP BY와 같은 작업은 WHERE 조건을 만족하는 레코드를 LIMIT 건수만큼만 가져와서는 처리할 수 없다.   
조건에 만족하는 레코드를 모두 가져와 정렬한 후 LIMIT으로 건수 제한을 할 수 있다.   
WHERE 조건이 아무리 인덱스를 잘 활용하도록 튜닝해도 잘못된 ORDER BY나 GROUP BY 때문에 쿼리가 느려지는 경우가 자주 발생한다.    

쿼리에서 인덱스를 사용하지 못하는 정렬이나 그룹핑 작업이 왜 느리게 작동할 수밖에 없는지 한번 살펴보자.    
<br />

* 스트리밍(Streaming) 방식   
  서버 쪽에서 처리해야 할 데이터가 얼마나 될지는 관계없이 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식을 의미한다.    
  이 방식으로 쿼리를 처리할 경우 클라이언트는 쿼리를 요청하고 곧바로 원했던 첫 번째 레코드를 전달받을 것이다.    
  MySQL 서버가 일치하는 레코드를 찾는 즉시 전달받기 때문에 동시에 데이터 가공 작업을 시작할 수 있다.    
  스트리밍 방식으로 처리되는 쿼리는 쿼리가 얼마나 많은 레코드를 조회하느냐에 상관없이 빠른 응답 시간을 보장해 준다. <br />         
  또한 스트리밍 방식으로 처리되는 쿼리에서 LIMIT와 같이 결과 건수를 제한하는 조건들은 쿼리의 전체 실행 시간을 상당히 줄여줄 수 있다.     
  매우 큰 테이블을 아무런 조건 없이 SELECT만 해 보면 첫 번째 레코드는 아주 빨리 가져올 것이다.    
  이것은 풀 테이블 스캔의 결과가 아무런 버퍼링 처리나 필터링 과정 없이 바로 클라이언트로 스트리밍되기 때문이다.     
  이 쿼리에 LIMIT 조건을 추가하면 전체적으로 가져오는 레코드 건수가 줄어들기 때문에 마지막 레코드를 가져오기까지의 시간을 상당히 줄일 수 있다.
  
<br />       
  
* 버퍼링(Buffering) 방식   
  ORDER BY나 GROUP BY과 같은 처리는 쿼리의 스트리밍되는 것을 불가능하게 한다.   
  WHERE 조건에 일치하는 모든 레코드를 가져온 후 정렬하거나 그룹핑을 해서 차례대로 보내야 하기 때문이다.    
  MySQL 서버에서는 모든 레코드를 검색하고 정렬 작업을 하는 동안 클라이언트는 아무것도 하지 않고 기다려야 하기 때문에 응답속도가 느려지는 것이다.   
  이 방식을 스트리밍의 반대 표현으로 버퍼링이라고 한다. <br />     
  버퍼링 방식으로 처리되는 쿼리는 먼저 결과를 모아서 MySQL 서버에서 일괄 가공해야 하므로 모든 결과를 스토리지 엔진으로부터 가져올 때까지 기다려야 한다.    
  그래서 버퍼링 방식으로 처리되는 쿼리는 LIMIT 처럼 결과 건수를 제한하는 조건이 있어도 성능 향상에 별로 도움이 되지 않는다.    
  네트워크로 전송되는 레코드의 건수를 줄일 수는 있지만 MySQL 서버가 해야 하는 작업량에는 그다지 변화가 없기 때문이다.   


<br />       

앞에서 나왔던 ORDER BY의 3가지 처리 방식 가운데 인덱스를 사용한 정렬 방식만 스트리밍 형태의 처리이며, 나머지는 모두 버퍼링된 후에 정렬된다.    
즉 인덱스를 사용한 정렬 방식은 LIMIT로 제한된 건수만큼만 읽으면서 바로바로 클라이언트로 결과를 전송해줄 수 있다.   
하지만 인덱스를 사용하지 못하는 경우의 처리는 필요한 모든 레코드를 디스크로부터 읽어서 정렬한 후에야    
비로소 LIMIT로 제한된 건수만큼 잘라서 클라이언트로 전송해줄 수 있음을 의미한다.       
<br />    

조인과 함께 ORDER BY 절과 LIMIT 절이 함께 사용될 경우, 정렬의 각 처리 방식별로 어떤 차이가 있는지 살펴보자.   

```
SELECT * 
FROM tb_test1 t1, tb_test2 t2
WHERE t1.col1=t2.col1;
ORDER BY t1.col2
LIMIT 10;
```

tb_test1 테이블의 레코드가 100건이고, tb_test2 테이블의 레코드가 1000건이며   
두 테이블의 조인 결과는 전체 1000건이라고 가정하고 정의 처리 방식별로 읽어야하는 레코드 건수와 정렬을 수행해야 하는 레코드 건수를 비교해보자.   

#### ⦁ tb_test1이 드라이빙이되는 경우   
|정렬 방식|읽어야 할 건수|조인 횟수|정렬해야 할 대상 건수|
|---|---|---|---|
|인덱스 사용|tb_test1 : 1건 <br /> tb_test2 : 10건|1번|0건|
|드라이빙 테이블만 정렬|tb_test1 : 100건 <br /> tb_test2 : 10건|10번|100건 <br /> (tb_test1 테이블의 레코드 건수만큼 정렬 필요)|
|임시 테이블 사용 후 정렬|tb_test1 : 100건 <br /> tb_test2 : 1000건|100번 <br /> (tb_test1 테이블의 레코드 건수만큼 조인 발생)|1000건 <br /> (조인된 결과 레코드 건수를 전부 정렬해야 함)|


<br />   

#### ⦁ tb_test2이 드라이빙이되는 경우   
|정렬 방식|읽어야 할 건수|조인 횟수|정렬해야 할 대상 건수|
|---|---|---|---|
|인덱스 사용|tb_test1 : 10건 <br /> tb_test2 : 10건|10번|0건|
|드라이빙 테이블만 정렬|tb_test1 : 1000건 <br /> tb_test2 : 10건|10번|1000건 <br /> (tb_test2 테이블의 레코드 건수만큼 정렬 필요)|
|임시 테이블 사용 후 정렬|tb_test1 : 1000건 <br /> tb_test2 : 100건|100번 <br /> (tb_test2 테이블의 레코드 건수만큼 조인 발생)|1000건 <br /> (조인된 결과 레코드 건수를 전부 정렬해야 함)|


<br />   

어느 테이블이 먼저 드라이빙되어 조인되는지도 중요하지만 어떤 정렬 방식으로 처리되는지는 더 큰 성능 차이를 만든다.   
가능하면 인덱스를 사용한 정렬로 유도하고 그렇지 못한다면 최소한 드라이빙 테이블만 정렬하도록 유도하는 것도 좋은 튜닝 방법이라고 할 수 있다.    


