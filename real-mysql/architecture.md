# MySQL 아키텍처      

쿼리를 작성하고 튜닝할 때 필요한 기본적인 구조에 대해서 알아보자.   


## MySQL의 전체 구조    

![스크린샷 2021-01-12 오전 12 20 44](https://user-images.githubusercontent.com/33855307/104200470-0e6a9800-546c-11eb-9aa0-cdc3a0db6534.png)     
<br />          


* MySQL 엔진    
클라이언트로부터 접속 및 쿼리 요청을 처리하는 커넥션 핸들러, SQL 파서 및 전처리기, 쿼리 최적화 실행을 위한 옵티마이저가 중심을 이룬다.   
또한 성능 향상을 위한 MyISAM의 키 캐시, InnoDB의 버퍼 풀이 포함된다.     

* 스토리지 엔진   
실제 데이터를 디스크 스토리지에 저장하거나 읽어오는 부분을 스토리지 엔진이 전담한다.     
예) `CREATE TABLE test_table(fd1 INT) ENGINE=INNODB;`      
위 예제는 InnoDB 스토리지 엔진을 사용하도록 정의한 것이다.       
test_table에 대한 쿼리 작업을 InnoDB 스토리지 엔진이 담당한다.   

* 핸들러 API   
MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때 각 스토리지 엔진에 요청을 하는데,             
이러한 요청을 핸들러 요청이라고 하며 여기서 사용되는 API를 핸들러 API라고 한다.             
<br />           

## MySQL 스레딩 구조      

![스크린샷 2021-01-12 오전 12 37 18](https://user-images.githubusercontent.com/33855307/104202502-58ed1400-546e-11eb-9b1a-ce3f749fcf75.png)     

MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동하며, 크게 포그라운드 스레드와 백그라운드 스레드로 구분할 수 있다.      


* 포그라운드 스레드 (클라이언트 스레드)   
포그라운드 스레드는 최소한 MySQL 서버에 접속된 클라이언트 수만큼 존재하며, 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리하는 것이 임무다.    

* 백드라운드 스레드       
MyISAM의 경우 별로 해당사항이 없지만 InnoDB는 여러 가지 작업이 백그라운드로 처리된다.        
모두 중요한 역할을 하지만 가장 중요한 것은 로그 스레드와 버퍼의 데이터를 디스크로 내려쓰는 작업을 처리하는 쓰기 스레드다.   
<br />      


## 메모리 할당 및 사용 구조    
MySQL에서 사용되는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있다.         
둘의 차이는 MySQL 서버 내에 존재하는 많은 스레드가 공유해서 사용하는지 아닌지에 따라 구분된다.     
<br />       

![스크린샷 2021-01-12 오전 12 48 51](https://user-images.githubusercontent.com/33855307/104203856-f4cb4f80-546f-11eb-8282-c57a121ed080.png)    
<br />           


* 글로벌 메모리 영역        
일반적으로 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당된다.       
단, 필요에 따라 2개 이상의 메모리 공간 할당 가능하지만 클라이언트의 스레드 수와 무관하고                            
생성된 글로벌 영역이 N개라 하더라도 모든 스레드에 의해 공유된다.            


* 로컬 메모리 영역        
세션 메모리 영역이라고도 표현하며, MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역이다.        
클라이언트가 MySQL 서버에 접속하면 MySQL 서버에서는 클라이언트 커넥션으로부터의 요청을 처리하기 위해 스레드를 하나씩 할당하게 되는데,    
클라이언트 스레드가 사용하는 메모리 공간이라고 해서 클라이언트 메모리 영역이라고도 한다.   
클라이언트와 MySQL 서버와의 커넥션을 세션이라고 하기 때문에 세션 메모리 영역이라고도 한다.       
로컬 메모리는 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다는 특징이 있다.         
<br />       


## 플러그인 스토리지 엔진 모델         
MySQL의 독특한 구조 중 대표적인 것이 플로그인 모델이다.         
MySQL에서 쿼리가 실행되는 과정을 크게 다음과 같이 나눈다면 거의 대부분의 작업이 MySQL 엔진에서 처리되고,   
마지막 "데이터 읽기/쓰기" 작업만 스토리지 엔진에 의해 처리된다.   

```
SQL 파서 ↔ SQL 옵티마이저 ↔ SQL 실행기 ↔ 데이터 읽기/쓰기 ↔ 디스크 스토리지
<------------------------------->  <----------->
      MySQL 엔진의 처리 영역        스토리지 엔진의 처리 영역 
```

MySQL에서 MyISAM이나 InnoDB와 같이 다른 스토리지 엔진을 사용하는 테이블에 대해 쿼리를 실행하더라도         
MySQL의 처리 내용은 대부분 동일하며 단순히 "데이터 읽기/쓰기" 영역의 처리만 차리가 있을 뿐이다.     
(MyISAM이나 InnoDB 스토리지 엔진 가운데 뭘 사용하든 별 차이가 없다는 이야기는 아니다.)       

실직적인 GROUP BY나 ORDER BY 등 많은 복잡한 처리는 스토리지 엔진 영역이 아니라 MySQL 엔진의 처리 영역인 쿼리 실행기에서 처리된다.    
하나의 쿼리 작업은 여러 하위 작업으로 나뉘는데, 각 하위 작업이 MySQL 엔진 영역에서 처리되는지 아니면     
스토리지 엔진 영역에서 처리되는지 구분할 줄 알아야 한다. 즉, 단위 작업을 추가 처리하고 MySQL 엔진 영역과 스토리지 엔진 영역의 차이를 알아야 한다.   
<br />       

MySQL 서버에서 지원되는 스토리지 엔진은 다음과 같다.      

```
mysql> SHOW ENGINES;
```

![스크린샷 2021-01-12 오후 9 38 45](https://user-images.githubusercontent.com/33855307/104315622-95784880-551e-11eb-8352-bb8a950911a2.png)    

Support 칼럼에 표시될 수 있는 값은 다음과 같다.    

* YES  
MySQL 서버에 해당 스토리지 엔진이 포함돼 있고, 사용 가능으로 활성화된 상태    

* DEFAULT   
YES와 동일한 상태이지만 필수 스토리지 엔진임을 의미  
(이 스토리지 엔진이 없으면 MySQL이 시작되지 않을 수도 있음을 의미)  

* NO
현재 MySQL 서버에 포함되지 않았음을 의미   

* DISABLED    
현재 MySQL 서버에는 포함됐지만 파라미터에 의해 비활성화된 상태     


  
스토리지 엔진과 플러그인의 내용은 `SHOW PLUGINS;` 명령어로 확인할 수 있다.       
<br />    

## 쿼리 실행 구조          
다음은 쿼리를 실행하는 관점에서 MySQL 구조를 간략하게 그린 것이다.    
      
![스크린샷 2021-01-12 오후 9 53 02](https://user-images.githubusercontent.com/33855307/104316941-8eead080-5520-11eb-9653-42e8de97a916.png)        

* 파서      
파서는 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업을 한다.       
쿼리 문장의 기본 문법 오류는 이 과정에서 발견되며 사용자에게 오류 메시지를 전달한다.       

* 전처리기      
파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다.      

* 옵티마이저     
옵티마이저란 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지 결정하는 역할을 담당하는데   
DBMS의 두뇌에 해당한다고 볼 수 있다.   

* 실행 엔진   
옵티마이저가 두뇌라면 실행 엔진과 핸들러는 손과 발에 비유할 수 있다.   
예를들어 옵티마이저가 GROUP BY를 처리하기 위해 임시 테이블을 사용하기로 결정했다고 해보자.    <br />          
(1) 실행 엔진은 핸들러에게 임시 테이블을 만들라고 요청 
(2) 다시 실행 엔진은 WHERE 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청   
(3) 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 다시 핸들러에게 요청   
(4) 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 다시 요청   
(5) 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김  <br />      
즉, 실행 엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행한다.   

* 핸들러 (스토리지 엔진)      
핸들러는 MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할을 담당한다.     
핸들러는 결국 스토리지 엔진을 의미하며 예를들어 MyISAM 테이블을 조작하는 경우에는 핸들러가 MyISAM 스토리지 엔진이 된다.      
<br />            




